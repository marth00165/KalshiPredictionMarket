# Executor & Dry-Run Explained

## What Does the Executor Do?

The **TradeExecutor** class handles the final step of the trading pipeline - actually placing bets on the markets.

### Job Description

```python
executor = TradeExecutor(config)
results = await executor.execute_signals([signal1, signal2, signal3])
```

The executor:

1. **Takes Trade Signals** - Receives list of `TradeSignal` objects (generated by the Strategy)
2. **Validates Each Signal** - Logs detailed information about what will be traded
3. **Routes to Platform** - Determines if signal is for Polymarket or Kalshi
4. **Calls Platform API** - Places actual bets (or simulates in dry-run mode)
5. **Returns Results** - Reports which trades succeeded/failed
6. **Handles Errors** - Converts API errors to custom exception types

### Key Methods

| Method                         | Purpose                                                    |
| ------------------------------ | ---------------------------------------------------------- |
| `execute_signals(signals)`     | Execute batch of signals, returns [True, False, True, ...] |
| `execute_signal(signal)`       | Execute single signal, raises exceptions in dry-run        |
| `_execute_on_platform(signal)` | Routes to Polymarket or Kalshi                             |
| `_log_signal(signal)`          | Pretty-prints signal details before execution              |
| `get_execution_stats()`        | Returns how many trades were executed                      |

### Example: What Gets Logged

When the executor encounters a signal, it logs:

```
================================================================================
ğŸ¯ TRADE SIGNAL
================================================================================
Market: Will Trump win the 2024 election?
Platform: polymarket
Action: BUY
Fair Value: 62.5%
Market Price: 55.0%
Edge: +7.5%
Kelly Fraction: 5.23%
Position Size: $523.00
Expected Value: +$39.23
Reasoning: Strong fundamental support with...
================================================================================
```

Then **in dry-run mode**, it raises `DryRunError` (which is caught and logged).  
**In live mode**, it would call the actual Polymarket/Kalshi API.

---

## What is Dry-Run?

**Dry-run** = "Test mode" or "Simulation mode" - runs the entire bot WITHOUT actually placing real bets.

### How It Works

```json
{
  "trading": {
    "dry_run": true,           â† Set to TRUE for testing
    "initial_bankroll": 1000
  }
}
```

### Dry-Run Flow

```
1. Load config with dry_run: true
2. Scanner finds markets âœ…
3. Strategy filters markets âœ…
4. Claude analyzes markets âœ…
5. Strategy finds opportunities âœ…
6. Strategy generates signals âœ…
7. EXECUTOR: Tries to execute...
   â†’ Raises DryRunError (non-fatal)
   â†’ Error caught and logged
   â†’ Continues without placing bet âœ…
8. Reports: "Would have placed $523 bet"
```

### Live-Run Flow

```
1. Load config with dry_run: false
2. Scanner finds markets âœ…
3. Strategy filters markets âœ…
4. Claude analyzes markets âœ…
5. Strategy finds opportunities âœ…
6. Strategy generates signals âœ…
7. EXECUTOR: Tries to execute...
   â†’ Calls Polymarket/Kalshi API âœ…
   â†’ Places actual bet âœ…
   â†’ Adds $523 to Platform âœ…
   â†’ Returns success to Position Manager
8. Reports: "Successfully placed $523 bet"
```

---

## Key Difference: Dry-Run vs Live

| Phase               | Dry-Run                     | Live                     | Result             |
| ------------------- | --------------------------- | ------------------------ | ------------------ |
| Market Scanning     | âœ… Hits real APIs           | âœ… Hits real APIs        | Same               |
| Claude Analysis     | âœ… Calls Claude             | âœ… Calls Claude          | **Costs money!**   |
| Opportunity Finding | âœ… Runs normally            | âœ… Runs normally         | Same               |
| Signal Generation   | âœ… Calculates Kelly         | âœ… Calculates Kelly      | Same               |
| **Trade Execution** | âŒ **BLOCKS (DryRunError)** | âœ… **Places bet**        | **Actual Money!**  |
| Position Tracking   | âœ… Tracks hypothetically    | âœ… Tracks real positions | Simulation vs Real |
| Error Reporting     | âœ… Logs everything          | âœ… Logs everything       | Same               |

---

## Code Flow: Understanding Dry-Run

### Step 1: Executor Checks Dry-Run Flag

```python
class TradeExecutor:
    def __init__(self, config: ConfigManager):
        self.dry_run = config.is_dry_run  # Read from config
        self.executed_trades = []
```

### Step 2: On Each Signal, Check Dry-Run

```python
async def execute_signal(self, signal: TradeSignal) -> bool:
    self._log_signal(signal)  # Always log

    if self.dry_run:
        # DRY-RUN MODE: Don't execute
        raise DryRunError(f"Not executing real trade for {signal.market.market_id}")

    # LIVE MODE: Execute for real
    try:
        success = await self._execute_on_platform(signal)
        if success:
            self.executed_trades.append(signal)
            return True
        else:
            raise ExecutionFailedError(...)
    except Exception as e:
        raise ExecutionFailedError(...)
```

### Step 3: Caller Catches DryRunError

In the main bot (`AdvancedTradingBot.run_trading_cycle()`):

```python
# Step 6: Execute trades
results = await self.executor.execute_signals(signals)

# Inside executor.execute_signals():
for signal in signals:
    try:
        success = await self.execute_signal(signal)
        results.append(success)
    except DryRunError as e:
        # DRY-RUN: Expected, just log
        logger.info(f"Dry-run: {e}")
        results.append(False)  # Mark as "not executed"
    except ExecutionFailedError as e:
        # LIVE MODE: Real error, serious problem
        logger.error(f"Execution failed: {e}")
        results.append(False)
```

---

## Why Dry-Run is Important

### Scenario: You Just Wrote This Bot

1. **First Run (DRY-RUN)**

   ```bash
   python main/ai_trading_bot_refactored.py --config config.json
   # Config has dry_run: true
   ```

   - Finds markets âœ…
   - Analyzes with Claude âœ… (costs $0.50)
   - Finds opportunities âœ…
   - Generates signals âœ…
   - **Tries to execute** â†’ DryRunError âœ…
   - Logs: "Would have placed 5 bets totaling $2,500"
   - No actual money spent on trading âœ…

2. **Code Review**
   - Check logs: "Are the opportunities real?"
   - Check signals: "Are position sizes reasonable?"
   - Check errors: "Any API failures?"

3. **If All Good: Switch to Live**
   ```json
   {
     "trading": {
       "dry_run": false,  â† Change only this
       "initial_bankroll": 1000
     }
   }
   ```

   - **Same run, but NOW places actual bets** ğŸ’¸

---

## The Executor's Currently Stubbed Methods

### Status: PLACEHOLDER IMPLEMENTATION

The executor currently has placeholder implementations for the actual API calls:

```python
async def _execute_polymarket(self, signal: TradeSignal) -> bool:
    """Execute trade on Polymarket (stub)"""
    # TODO: Implement Polymarket order placement
    logger.info(f"Would execute on Polymarket: {signal}")
    return True  # â† Always returns True (fake success)

async def _execute_kalshi(self, signal: TradeSignal) -> bool:
    """Execute trade on Kalshi (stub)"""
    # TODO: Implement Kalshi order placement
    logger.info(f"Would execute on Kalshi: {signal}")
    return True  # â† Always returns True (fake success)
```

### What Needs to Be Implemented

When you're ready for real trading, these methods need actual API calls:

**Polymarket:**

```python
async def _execute_polymarket(self, signal: TradeSignal) -> bool:
    # 1. Get order book for market_id
    # 2. Calculate optimal order parameters
    # 3. POST to /orders endpoint
    # 4. Wait for confirmation
    # 5. Return success/failure
```

**Kalshi:**

```python
async def _execute_kalshi(self, signal: TradeSignal) -> bool:
    # 1. Get orderbook for contract_id
    # 2. Calculate optimal order parameters
    # 3. POST to /trade endpoint
    # 4. Wait for confirmation
    # 5. Return success/failure
```

### Using the Stub Methods Now

Even with stubs, dry-run mode is still valuable:

1. Tests full pipeline (scanning â†’ analysis â†’ signals)
2. Validates config and error handling
3. Checks Claude API works correctly
4. Verifies market filtering works
5. When you add real implementations, dry-run tests them safely first

---

## Complete Execution Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AdvancedTradingBot.run_trading_cycle()                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
    Step 1: Scanner.scan_all_markets()
    â†’ Calls PolymarketClient and KalshiClient
    â†’ Gets live market data
              â†“
    Step 2: Strategy.filter_markets(markets)
    â†’ Filters by volume/liquidity
              â†“
    Step 3: ClaudeAnalyzer.analyze_market_batch(markets)
    â†’ Sends to Claude API
    â†’ Gets fair value estimates
              â†“
    Step 4: Strategy.find_opportunities(estimates, markets)
    â†’ Compares fair value vs market price
    â†’ Keeps only >8% edge trades
              â†“
    Step 5: Strategy.generate_trade_signals(opportunities)
    â†’ Calculates Kelly position sizing
    â†’ Creates TradeSignal objects with size
              â†“
    Step 6: PositionManager.add_position(signal)
    â†’ Validates bankroll available
    â†’ Reserves capital
              â†“
    Step 7: TradeExecutor.execute_signals(signals)  â† ğŸ¯ HERE
    â”‚
    â”œâ”€ For each signal:
    â”‚   â”œâ”€ DRY-RUN (dry_run: true)
    â”‚   â”‚  â””â”€ Logs signal, raises DryRunError, continues
    â”‚   â”‚
    â”‚   â””â”€ LIVE (dry_run: false)
    â”‚      â”œâ”€ Calls _execute_on_platform()
    â”‚      â”œâ”€ Calls PolymarketClient or KalshiClient
    â”‚      â”œâ”€ Places actual bet
    â”‚      â””â”€ Returns success/failure
    â”‚
    â””â”€ Returns [True, False, True, ...] for each signal
              â†“
    Step 8: ErrorReporter.log_summary()
    â†’ Reports all errors from cycle
```

---

## How to Test Different Scenarios

### Scenario 1: Test Market Scanning Only

```python
# Remove dry_run flag check, just load config
scanner = MarketScanner(config)
markets = await scanner.scan_all_markets()
print(f"Found {len(markets)} markets")
```

### Scenario 2: Test Claude Analysis

```python
analyzer = ClaudeAnalyzer(config)
markets = await scanner.scan_all_markets()
estimates = await analyzer.analyze_market_batch(markets)
for est in estimates:
    print(f"{est.market_id}: ${est.fair_value:.0%}")
```

### Scenario 3: Test Strategy

```python
strategy = Strategy(config)
opportunities = strategy.find_opportunities(estimates, markets)
signals = strategy.generate_trade_signals(opportunities, bankroll=10000)
for signal in signals:
    print(f"BUY ${signal.position_size} at {signal.market_price:.0%}")
```

### Scenario 4: Test Executor in Dry-Run

```python
config.trading.dry_run = True  # Ensure dry-run
executor = TradeExecutor(config)
results = await executor.execute_signals(signals)
# Will raise DryRunError for each, but log everything
```

### Scenario 5: Test Full Cycle in Dry-Run

```bash
python main/ai_trading_bot_refactored.py
# Uses advanced_config.json with dry_run: true
```

### Scenario 6: Go Live (After Testing)

```bash
# Edit advanced_config.json
# Change dry_run: true â†’ dry_run: false
python main/ai_trading_bot_refactored.py
```

---

## Summary

| Concept            | Explanation                                                  |
| ------------------ | ------------------------------------------------------------ |
| **Executor**       | Final component that places bets (or tries to in dry-run)    |
| **Dry-Run**        | Config flag that blocks actual execution with DryRunError    |
| **Live Mode**      | dry_run: false enables actual betting (real money!)          |
| **Safe Testing**   | Dry-run lets you test entire pipeline without risking money  |
| **Stubs**          | Polymarket/Kalshi API calls not yet implemented (TODOs)      |
| **Error Handling** | DryRunError is non-fatal, ExecutionFailedError is critical   |
| **Flow**           | All 8 steps run identically; only Step 7 (execution) differs |

**Golden Rule**: Always test with `dry_run: true` first, then change one setting to go live.
